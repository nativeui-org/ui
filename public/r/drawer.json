{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "drawer",
  "type": "registry:component",
  "title": "Drawer",
  "description": "A drawer component for React Native applications.",
  "dependencies": [
    "react-native"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/drawer/drawer.tsx",
      "content": "import * as React from \"react\";\nimport {\n  View,\n  Text,\n  Modal,\n  TouchableWithoutFeedback,\n  Platform,\n  Animated,\n  PanResponder,\n  Dimensions,\n  StyleSheet,\n  Easing,\n  KeyboardAvoidingView,\n} from \"react-native\";\nimport { SafeAreaView } from \"react-native-safe-area-context\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DrawerProps {\n  open: boolean;\n  onClose: () => void;\n  children: React.ReactNode;\n  title?: string;\n  snapPoints?: number[];\n  initialSnapIndex?: number;\n  className?: string;\n  contentClassName?: string;\n  avoidKeyboard?: boolean;\n  closeOnBackdropPress?: boolean;\n  disableBackHandler?: boolean;\n}\n\nconst { height: SCREEN_HEIGHT } = Dimensions.get(\"window\");\nconst DEFAULT_SNAP_POINTS = [0.5, 0.9]; // 0.5 = 50% of screen height, 0.9 = 90% of screen height\n\nexport const DrawerContext = React.createContext<{ animateClose: () => void }>({\n  animateClose: () => {},\n});\n\nexport const useDrawer = () => React.useContext(DrawerContext);\n\nconst Drawer = React.forwardRef<View, DrawerProps>(\n  (\n    {\n      open,\n      onClose,\n      children,\n      title,\n      snapPoints = DEFAULT_SNAP_POINTS,\n      initialSnapIndex = 0,\n      className,\n      contentClassName,\n      avoidKeyboard = true,\n      closeOnBackdropPress = true,\n      disableBackHandler = false,\n    },\n    ref\n  ) => {\n    const [isVisible, setIsVisible] = React.useState(false);\n    const snapPointsPixels = snapPoints.map(\n      (point) => SCREEN_HEIGHT - SCREEN_HEIGHT * point\n    );\n\n    const activeSnapIndex = React.useRef(initialSnapIndex);\n    const translateY = React.useRef(new Animated.Value(SCREEN_HEIGHT)).current;\n    const backdropOpacity = React.useRef(new Animated.Value(0)).current;\n    const isClosing = React.useRef(false);\n\n    const animateOpen = React.useCallback(() => {\n      translateY.setValue(SCREEN_HEIGHT);\n      backdropOpacity.setValue(0);\n      isClosing.current = false;\n\n      Animated.timing(backdropOpacity, {\n        toValue: 1,\n        duration: 180,\n        useNativeDriver: true,\n        easing: Easing.out(Easing.ease),\n      }).start();\n\n      Animated.spring(translateY, {\n        toValue: snapPointsPixels[initialSnapIndex],\n        useNativeDriver: true,\n        velocity: 3,\n        tension: 120,\n        friction: 22,\n      }).start();\n\n      activeSnapIndex.current = initialSnapIndex;\n    }, [backdropOpacity, translateY, snapPointsPixels, initialSnapIndex]);\n\n    const animateClose = React.useCallback(() => {\n      if (isClosing.current) return;\n\n      isClosing.current = true;\n\n      Animated.spring(translateY, {\n        toValue: SCREEN_HEIGHT,\n        useNativeDriver: true,\n        friction: 26,\n        tension: 100,\n        velocity: 0.5,\n      }).start();\n\n      Animated.timing(backdropOpacity, {\n        toValue: 0,\n        duration: 280,\n        easing: Easing.out(Easing.ease),\n        useNativeDriver: true,\n        delay: 100,\n      }).start(() => {\n        setIsVisible(false);\n        isClosing.current = false;\n        onClose();\n      });\n    }, [backdropOpacity, translateY, onClose]);\n\n    React.useEffect(() => {\n      if (open && !isVisible) {\n        setIsVisible(true);\n      } else if (open && !isClosing.current) {\n        animateOpen();\n      } else if (!open && isVisible && !isClosing.current) {\n        animateClose();\n      }\n    }, [open, isVisible, animateOpen, animateClose, isClosing]);\n\n    const animateToSnapPoint = (index: number, velocity = 0) => {\n      if (index < 0 || index >= snapPointsPixels.length) return;\n\n      activeSnapIndex.current = index;\n\n      Animated.spring(translateY, {\n        toValue: snapPointsPixels[index],\n        useNativeDriver: true,\n        velocity: velocity,\n        tension: 120,\n        friction: 22,\n      }).start();\n    };\n\n    const getTargetSnapIndex = (\n      currentY: number,\n      velocity: number,\n      dragDirection: \"up\" | \"down\"\n    ) => {\n      const isDraggingDown = dragDirection === \"down\";\n\n      if (\n        activeSnapIndex.current === snapPointsPixels.length - 1 &&\n        isDraggingDown\n      ) {\n        return snapPointsPixels.length - 2;\n      }\n\n      if (activeSnapIndex.current === 1 && isDraggingDown && velocity > 0.3) {\n        return 0;\n      }\n\n      if (activeSnapIndex.current === 0 && isDraggingDown && velocity > 0.5) {\n        return -1;\n      }\n\n      if (currentY > snapPointsPixels[0] + 100) {\n        return -1;\n      }\n\n      if (dragDirection === \"up\" && velocity > 0.3) {\n        const nextIndex = Math.min(\n          activeSnapIndex.current + 1,\n          snapPointsPixels.length - 1\n        );\n        return nextIndex;\n      }\n\n      let closestIndex = 0;\n      let minDistance = Math.abs(currentY - snapPointsPixels[0]);\n\n      for (let i = 1; i < snapPointsPixels.length; i++) {\n        const distance = Math.abs(currentY - snapPointsPixels[i]);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestIndex = i;\n        }\n      }\n\n      return closestIndex;\n    };\n\n    const panResponder = React.useMemo(() => {\n      let startY = 0;\n      const maxDragPoint = snapPointsPixels[snapPointsPixels.length - 1];\n\n      return PanResponder.create({\n        onStartShouldSetPanResponder: () => true,\n        onMoveShouldSetPanResponder: (_, { dy }) => Math.abs(dy) > 5,\n\n        onPanResponderGrant: (_, { y0 }) => {\n          startY = y0;\n          translateY.stopAnimation();\n        },\n\n        onPanResponderMove: (_, { dy }) => {\n          if (isClosing.current) return;\n\n          const currentSnapY = snapPointsPixels[activeSnapIndex.current];\n          let newY = currentSnapY + dy;\n\n          if (newY < maxDragPoint) {\n            const overscroll = maxDragPoint - newY;\n            const resistedOverscroll = -Math.log10(1 + overscroll * 0.1) * 10;\n            newY = maxDragPoint + resistedOverscroll;\n          }\n\n          translateY.setValue(newY);\n        },\n\n        onPanResponderRelease: (_, { dy, vy, moveY }) => {\n          if (isClosing.current) return;\n\n          const dragDirection = dy > 0 ? \"down\" : \"up\";\n          const currentY = snapPointsPixels[activeSnapIndex.current] + dy;\n          const absVelocity = Math.abs(vy);\n\n          const targetIndex = getTargetSnapIndex(\n            currentY,\n            absVelocity,\n            dragDirection\n          );\n\n          if (targetIndex === -1) {\n            animateClose();\n          } else {\n            animateToSnapPoint(targetIndex, vy);\n          }\n        },\n      });\n    }, [snapPointsPixels, animateClose]);\n\n    if (!isVisible) return null;\n\n    const renderContent = () => (\n      <View className=\"flex-1\">\n        <Animated.View style={[styles.backdrop, { opacity: backdropOpacity }]}>\n          {closeOnBackdropPress && (\n            <TouchableWithoutFeedback onPress={animateClose}>\n              <View style={StyleSheet.absoluteFillObject} />\n            </TouchableWithoutFeedback>\n          )}\n        </Animated.View>\n\n        <Animated.View\n          style={[styles.drawerContainer, { transform: [{ translateY }] }]}\n          className={cn(\n            \"absolute bottom-0 left-0 right-0 bg-popover rounded-t-xl overflow-hidden\",\n            Platform.OS === \"ios\" ? \"ios:shadow-xl\" : \"android:elevation-24\",\n            contentClassName\n          )}\n        >\n          <View {...panResponder.panHandlers}>\n            <View className=\"w-full items-center py-2\">\n              <View className=\"w-10 h-1 rounded-full bg-muted-foreground/30\" />\n            </View>\n\n            {title && (\n              <View className=\"px-4 pt-1 pb-3 border-b border-border\">\n                <Text className=\"text-xl font-medium text-center text-foreground\">\n                  {title}\n                </Text>\n              </View>\n            )}\n          </View>\n\n          <SafeAreaView className=\"flex-1\" edges={[\"bottom\"]}>\n            <View ref={ref} className=\"flex-1\">\n              {children}\n            </View>\n          </SafeAreaView>\n        </Animated.View>\n      </View>\n    );\n\n    return (\n      <DrawerContext.Provider value={{ animateClose }}>\n        <Modal\n          visible={isVisible}\n          transparent\n          animationType=\"none\"\n          statusBarTranslucent\n          onRequestClose={disableBackHandler ? undefined : animateClose}\n        >\n          {avoidKeyboard && Platform.OS === \"ios\" ? (\n            <KeyboardAvoidingView\n              behavior=\"padding\"\n              style={{ flex: 1 }}\n              keyboardVerticalOffset={10}\n            >\n              {renderContent()}\n            </KeyboardAvoidingView>\n          ) : (\n            renderContent()\n          )}\n        </Modal>\n      </DrawerContext.Provider>\n    );\n  }\n);\n\nconst styles = StyleSheet.create({\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.4)\",\n  },\n  drawerContainer: {\n    height: SCREEN_HEIGHT,\n    paddingBottom: 20,\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: -3 },\n    shadowOpacity: 0.15,\n    shadowRadius: 8,\n    elevation: 24,\n  },\n});\n\nDrawer.displayName = \"Drawer\";\n\nexport { Drawer };\n",
      "type": "registry:component"
    }
  ]
}