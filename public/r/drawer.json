{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "drawer",
  "type": "registry:component",
  "title": "Drawer",
  "description": "A drawer component for React Native applications.",
  "dependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/drawer/drawer.tsx",
      "content": "import * as React from \"react\";\nimport {\n  View,\n  Text,\n  Modal,\n  TouchableWithoutFeedback,\n  Platform,\n  Animated,\n  PanResponder,\n  Dimensions,\n  StyleSheet,\n  Easing,\n  KeyboardAvoidingView,\n} from \"react-native\";\nimport { SafeAreaView } from \"react-native-safe-area-context\";\nimport { cn } from \"@/lib/utils\";\n\n// Animation config constants\nconst ANIMATION = {\n  OPEN: {\n    BACKDROP_DURATION: 180,\n    SPRING_VELOCITY: 3,\n    SPRING_TENSION: 120,\n    SPRING_FRICTION: 22,\n  },\n  CLOSE: {\n    SPRING_FRICTION: 26,\n    SPRING_TENSION: 100,\n    SPRING_VELOCITY: 0.5,\n    BACKDROP_DURATION: 280,\n    BACKDROP_DELAY: 100,\n  },\n  SNAP: {\n    SPRING_TENSION: 120,\n    SPRING_FRICTION: 22,\n  },\n};\n\n// Drag behavior constants\nconst DRAG = {\n  THRESHOLD: 5,\n  CLOSE_DISTANCE: 100,\n  VELOCITY_THRESHOLD: {\n    UP: 0.3,\n    DOWN: 0.5,\n  },\n  RESISTANCE: 0.1,\n};\n\n// Drawer sizes - Definition of preset snap points\nconst DRAWER_SIZES = {\n  SMALL: [0.3, 0.5], // Small drawer that can be extended to 50%\n  MEDIUM: [0.5, 0.8], // Medium drawer that can be extended to 80%\n  LARGE: [0.6, 0.8, 0.95], // Large drawer with size options\n  FULL: [0.8, 0.95], // Full screen with reduced option\n};\n\nconst { height: SCREEN_HEIGHT } = Dimensions.get(\"window\");\n\nexport type DrawerSize = \"small\" | \"medium\" | \"large\" | \"full\" | number[];\n\nconst resolveSnapPoints = (size: DrawerSize): number[] => {\n  if (Array.isArray(size)) return size;\n\n  switch (size) {\n    case \"small\":\n      return DRAWER_SIZES.SMALL;\n    case \"medium\":\n      return DRAWER_SIZES.MEDIUM;\n    case \"large\":\n      return DRAWER_SIZES.LARGE;\n    case \"full\":\n      return DRAWER_SIZES.FULL;\n    default:\n      return DRAWER_SIZES.MEDIUM;\n  }\n};\n\ninterface DrawerProps {\n  open: boolean;\n  onClose: () => void;\n  children: React.ReactNode;\n  title?: string;\n  size?: DrawerSize;\n  initialSnapIndex?: number;\n  snapPoints?: number[];\n  contentClassName?: string;\n  avoidKeyboard?: boolean;\n  closeOnBackdropPress?: boolean;\n  disableBackHandler?: boolean;\n}\n\ninterface DrawerContextValue {\n  close: () => void;\n  snapTo: (index: number) => void;\n  currentSnapIndex: number;\n  snapPoints: number[];\n  isClosing: boolean;\n  isAnimating: boolean;\n  position: Animated.Value;\n}\n\nexport const DrawerContext = React.createContext<DrawerContextValue>({\n  close: () => { },\n  snapTo: () => { },\n  currentSnapIndex: 0,\n  snapPoints: DRAWER_SIZES.MEDIUM,\n  isClosing: false,\n  isAnimating: false,\n  position: new Animated.Value(0),\n});\n\nexport const useDrawer = () => React.useContext(DrawerContext);\n\nconst Drawer = React.forwardRef<View, DrawerProps>(\n  (\n    {\n      open,\n      onClose,\n      children,\n      title,\n      size = \"medium\",\n      initialSnapIndex = 0,\n      snapPoints: providedSnapPoints,\n      contentClassName,\n      avoidKeyboard = true,\n      closeOnBackdropPress = true,\n      disableBackHandler = false,\n    },\n    ref\n  ) => {\n    const [isVisible, setIsVisible] = React.useState(false);\n    const snapPoints = React.useMemo(\n      () => providedSnapPoints || resolveSnapPoints(size),\n      [size, providedSnapPoints]\n    );\n    const snapPointsPixels = React.useMemo(\n      () => snapPoints.map((point) => SCREEN_HEIGHT - SCREEN_HEIGHT * point),\n      [snapPoints]\n    );\n\n    const activeSnapIndex = React.useRef(initialSnapIndex);\n    const translateY = React.useRef(new Animated.Value(SCREEN_HEIGHT)).current;\n    const backdropOpacity = React.useRef(new Animated.Value(0)).current;\n    const isClosing = React.useRef(false);\n    const isAnimating = React.useRef(false);\n    const hasInitializedOpen = React.useRef(false);\n\n    const animateOpen = React.useCallback(() => {\n      if (isAnimating.current) {\n        translateY.stopAnimation();\n        backdropOpacity.stopAnimation();\n      }\n\n      isAnimating.current = true;\n      translateY.setValue(SCREEN_HEIGHT);\n      backdropOpacity.setValue(0);\n      isClosing.current = false;\n\n      Animated.timing(backdropOpacity, {\n        toValue: 1,\n        duration: ANIMATION.OPEN.BACKDROP_DURATION,\n        useNativeDriver: true,\n        easing: Easing.out(Easing.ease),\n      }).start();\n\n      Animated.spring(translateY, {\n        toValue: snapPointsPixels[initialSnapIndex],\n        useNativeDriver: true,\n        velocity: ANIMATION.OPEN.SPRING_VELOCITY,\n        tension: ANIMATION.OPEN.SPRING_TENSION,\n        friction: ANIMATION.OPEN.SPRING_FRICTION,\n      }).start(() => {\n        isAnimating.current = false;\n        activeSnapIndex.current = initialSnapIndex;\n      });\n    }, [backdropOpacity, translateY, snapPointsPixels, initialSnapIndex]);\n\n    const animateClose = React.useCallback(() => {\n      if (isClosing.current) return;\n\n      isClosing.current = true;\n\n      if (isAnimating.current) {\n        translateY.stopAnimation();\n        backdropOpacity.stopAnimation();\n      }\n\n      isAnimating.current = true;\n\n      Animated.spring(translateY, {\n        toValue: SCREEN_HEIGHT,\n        useNativeDriver: true,\n        friction: ANIMATION.CLOSE.SPRING_FRICTION,\n        tension: ANIMATION.CLOSE.SPRING_TENSION,\n        velocity: ANIMATION.CLOSE.SPRING_VELOCITY,\n      }).start();\n\n      Animated.timing(backdropOpacity, {\n        toValue: 0,\n        duration: ANIMATION.CLOSE.BACKDROP_DURATION,\n        easing: Easing.out(Easing.ease),\n        useNativeDriver: true,\n        delay: ANIMATION.CLOSE.BACKDROP_DELAY,\n      }).start(() => {\n        requestAnimationFrame(() => {\n          setIsVisible(false);\n          isClosing.current = false;\n          isAnimating.current = false;\n          hasInitializedOpen.current = false;\n          onClose();\n        });\n      });\n    }, [backdropOpacity, translateY, onClose]);\n\n    React.useEffect(() => {\n      if (open && !isVisible) {\n        setIsVisible(true);\n        return;\n      }\n\n      if (\n        open &&\n        isVisible &&\n        !hasInitializedOpen.current &&\n        !isClosing.current\n      ) {\n        animateOpen();\n        hasInitializedOpen.current = true;\n        return;\n      }\n\n      if (!open && isVisible && !isClosing.current) {\n        animateClose();\n      }\n    }, [open, isVisible, animateOpen, animateClose]);\n\n    const handleBackdropPress = React.useCallback(() => {\n      if (closeOnBackdropPress && !isClosing.current) {\n        isClosing.current = true;\n        isAnimating.current = true;\n\n        Animated.spring(translateY, {\n          toValue: SCREEN_HEIGHT,\n          useNativeDriver: true,\n          friction: ANIMATION.CLOSE.SPRING_FRICTION,\n          tension: ANIMATION.CLOSE.SPRING_TENSION,\n          velocity: ANIMATION.CLOSE.SPRING_VELOCITY,\n        }).start();\n\n        Animated.timing(backdropOpacity, {\n          toValue: 0,\n          duration: ANIMATION.CLOSE.BACKDROP_DURATION,\n          easing: Easing.out(Easing.ease),\n          useNativeDriver: true,\n          delay: ANIMATION.CLOSE.BACKDROP_DELAY,\n        }).start(() => {\n          requestAnimationFrame(() => {\n            setIsVisible(false);\n            isClosing.current = false;\n            isAnimating.current = false;\n            hasInitializedOpen.current = false;\n            onClose();\n          });\n        });\n      }\n    }, [backdropOpacity, translateY, onClose, closeOnBackdropPress]);\n\n    const animateToSnapPoint = React.useCallback(\n      (index: number, velocity = 0) => {\n        if (\n          index < 0 ||\n          index >= snapPointsPixels.length ||\n          isAnimating.current\n        )\n          return;\n\n        isAnimating.current = true;\n        activeSnapIndex.current = index;\n\n        Animated.spring(translateY, {\n          toValue: snapPointsPixels[index],\n          useNativeDriver: true,\n          velocity: velocity,\n          tension: ANIMATION.SNAP.SPRING_TENSION,\n          friction: ANIMATION.SNAP.SPRING_FRICTION,\n        }).start(() => {\n          isAnimating.current = false;\n        });\n      },\n      [snapPointsPixels]\n    );\n\n    const getTargetSnapIndex = React.useCallback(\n      (currentY: number, velocity: number, dragDirection: \"up\" | \"down\") => {\n        const isDraggingDown = dragDirection === \"down\";\n\n        if (\n          activeSnapIndex.current === snapPointsPixels.length - 1 &&\n          isDraggingDown\n        ) {\n          return snapPointsPixels.length - 2 >= 0\n            ? snapPointsPixels.length - 2\n            : 0;\n        }\n\n        if (\n          activeSnapIndex.current === 1 &&\n          isDraggingDown &&\n          velocity > DRAG.VELOCITY_THRESHOLD.UP\n        ) {\n          return 0;\n        }\n\n        if (\n          activeSnapIndex.current === 0 &&\n          isDraggingDown &&\n          velocity > DRAG.VELOCITY_THRESHOLD.DOWN\n        ) {\n          return -1;\n        }\n\n        if (currentY > snapPointsPixels[0] + DRAG.CLOSE_DISTANCE) {\n          return -1;\n        }\n\n        if (dragDirection === \"up\" && velocity > DRAG.VELOCITY_THRESHOLD.UP) {\n          const nextIndex = Math.min(\n            activeSnapIndex.current + 1,\n            snapPointsPixels.length - 1\n          );\n          return nextIndex;\n        }\n\n        let closestIndex = 0;\n        let minDistance = Math.abs(currentY - snapPointsPixels[0]);\n\n        for (let i = 1; i < snapPointsPixels.length; i++) {\n          const distance = Math.abs(currentY - snapPointsPixels[i]);\n          if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n          }\n        }\n\n        return closestIndex;\n      },\n      [snapPointsPixels]\n    );\n\n    const panResponder = React.useMemo(() => {\n      let startY = 0;\n      const maxDragPoint = snapPointsPixels.length\n        ? snapPointsPixels[snapPointsPixels.length - 1]\n        : 0;\n\n      return PanResponder.create({\n        onStartShouldSetPanResponder: () =>\n          !isClosing.current && !isAnimating.current,\n        onMoveShouldSetPanResponder: (_, { dy }) =>\n          !isClosing.current &&\n          !isAnimating.current &&\n          Math.abs(dy) > DRAG.THRESHOLD,\n\n        onPanResponderGrant: (_, { y0 }) => {\n          startY = y0;\n          translateY.stopAnimation();\n          isAnimating.current = false;\n        },\n\n        onPanResponderMove: (_, { dy }) => {\n          if (isClosing.current) return;\n\n          const currentSnapY = snapPointsPixels[activeSnapIndex.current];\n          let newY = currentSnapY + dy;\n\n          if (newY < maxDragPoint) {\n            const overscroll = maxDragPoint - newY;\n            const resistedOverscroll =\n              -Math.log10(1 + overscroll * DRAG.RESISTANCE) * 10;\n            newY = maxDragPoint + resistedOverscroll;\n          }\n\n          translateY.setValue(newY);\n        },\n\n        onPanResponderRelease: (_, { dy, vy }) => {\n          if (isClosing.current) return;\n\n          const dragDirection = dy > 0 ? \"down\" : \"up\";\n          const currentY = snapPointsPixels[activeSnapIndex.current] + dy;\n          const absVelocity = Math.abs(vy);\n\n          const targetIndex = getTargetSnapIndex(\n            currentY,\n            absVelocity,\n            dragDirection\n          );\n\n          if (targetIndex === -1) {\n            animateClose();\n          } else {\n            animateToSnapPoint(targetIndex, vy);\n          }\n        },\n      });\n    }, [\n      snapPointsPixels,\n      animateClose,\n      animateToSnapPoint,\n      getTargetSnapIndex,\n    ]);\n\n    const contextValue = React.useMemo(\n      () => ({\n        close: animateClose,\n        snapTo: animateToSnapPoint,\n        currentSnapIndex: activeSnapIndex.current,\n        snapPoints,\n        isClosing: isClosing.current,\n        isAnimating: isAnimating.current,\n        position: translateY,\n      }),\n      [animateClose, animateToSnapPoint, snapPoints, translateY]\n    );\n\n    const renderContent = React.useCallback(\n      () => (\n        <View className=\"flex-1\">\n          <Animated.View\n            style={[styles.backdrop, { opacity: backdropOpacity }]}\n          >\n            {closeOnBackdropPress && (\n              <TouchableWithoutFeedback onPress={handleBackdropPress}>\n                <View style={StyleSheet.absoluteFillObject} />\n              </TouchableWithoutFeedback>\n            )}\n          </Animated.View>\n\n          <Animated.View\n            style={[styles.drawerContainer, { transform: [{ translateY }] }]}\n            className={cn(\n              \"absolute bottom-0 left-0 right-0 bg-popover rounded-t-xl overflow-hidden\",\n              Platform.OS === \"ios\" ? \"ios:shadow-xl\" : \"android:elevation-24\",\n              contentClassName\n            )}\n          >\n            <View {...panResponder.panHandlers}>\n              <View className=\"w-full items-center py-2\">\n                <View className=\"w-10 h-1 rounded-full bg-muted-foreground/30\" />\n              </View>\n\n              {title && (\n                <View className=\"px-4 pt-1 pb-3 border-b border-border\">\n                  <Text className=\"text-xl font-medium text-center text-foreground\">\n                    {title}\n                  </Text>\n                </View>\n              )}\n            </View>\n\n            <SafeAreaView className=\"flex-1\" edges={[\"bottom\"]}>\n              <View ref={ref} className=\"flex-1\">\n                {children}\n              </View>\n            </SafeAreaView>\n          </Animated.View>\n        </View>\n      ),\n      [\n        animateClose,\n        backdropOpacity,\n        closeOnBackdropPress,\n        contentClassName,\n        panResponder.panHandlers,\n        title,\n        translateY,\n        children,\n        ref,\n      ]\n    );\n\n    if (!isVisible) return null;\n\n    return (\n      <DrawerContext.Provider value={contextValue}>\n        <Modal\n          visible={isVisible}\n          transparent\n          animationType=\"none\"\n          statusBarTranslucent\n          onRequestClose={disableBackHandler ? undefined : animateClose}\n        >\n          {avoidKeyboard && Platform.OS === \"ios\" ? (\n            <KeyboardAvoidingView\n              behavior=\"padding\"\n              style={{ flex: 1 }}\n              keyboardVerticalOffset={10}\n            >\n              {renderContent()}\n            </KeyboardAvoidingView>\n          ) : (\n            renderContent()\n          )}\n        </Modal>\n      </DrawerContext.Provider>\n    );\n  }\n);\n\nconst styles = StyleSheet.create({\n  backdrop: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: \"rgba(0, 0, 0, 0.4)\",\n  },\n  drawerContainer: {\n    height: SCREEN_HEIGHT,\n    paddingBottom: 20,\n    shadowColor: \"#000\",\n    shadowOffset: { width: 0, height: -3 },\n    shadowOpacity: 0.15,\n    shadowRadius: 8,\n    elevation: 24,\n  },\n});\n\nDrawer.displayName = \"Drawer\";\n\nexport { Drawer };\n",
      "type": "registry:component"
    }
  ],
  "changelog": [],
  "customUsage": "",
  "customPreview": ""
}